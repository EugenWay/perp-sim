//! Keystore management for Vara Network bot accounts
//!
//! Handles loading and decrypting keys generated by `gring` tool.
//! Keys are stored in JSON files with encrypted private keys.

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};

/// Error type for keystore operations
#[derive(Debug)]
pub enum KeystoreError {
    /// Key file not found
    NotFound(String),
    /// Failed to read key file
    ReadError(String),
    /// Failed to parse key file
    ParseError(String),
    /// Failed to decrypt key
    DecryptError(String),
    /// Passphrase file not found
    PassphraseNotFound(String),
    /// Invalid key format
    InvalidFormat(String),
}

impl std::fmt::Display for KeystoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NotFound(s) => write!(f, "Key not found: {}", s),
            Self::ReadError(s) => write!(f, "Read error: {}", s),
            Self::ParseError(s) => write!(f, "Parse error: {}", s),
            Self::DecryptError(s) => write!(f, "Decrypt error: {}", s),
            Self::PassphraseNotFound(s) => write!(f, "Passphrase not found: {}", s),
            Self::InvalidFormat(s) => write!(f, "Invalid format: {}", s),
        }
    }
}

impl std::error::Error for KeystoreError {}

/// Encrypted key file format (gring JSON format)
#[derive(Debug, Serialize, Deserialize)]
struct EncryptedKeyFile {
    /// Key name (e.g., "bot_001")
    name: String,
    /// Public address (SS58 encoded)
    address: String,
    /// Encrypted private key data
    encoded: String,
    /// Encryption metadata
    encoding: EncodingInfo,
}

#[derive(Debug, Serialize, Deserialize)]
struct EncodingInfo {
    content: Vec<String>,
    #[serde(rename = "type")]
    encoding_type: Vec<String>,
    version: String,
}

/// Decrypted keypair for signing transactions
#[derive(Clone)]
pub struct KeyPair {
    /// Key name (e.g., "bot_001")
    pub name: String,
    /// Public address (SS58 format)
    pub address: String,
    /// Public key bytes (32 bytes for sr25519)
    pub public_key: [u8; 32],
    /// Seed/secret for signing (kept private)
    seed: Vec<u8>,
}

impl KeyPair {
    /// Get the account ID (32-byte public key)
    pub fn account_id(&self) -> [u8; 32] {
        self.public_key
    }

    /// Get the seed for gclient signing
    /// Note: This exposes the secret - use carefully
    pub fn seed_phrase(&self) -> &[u8] {
        &self.seed
    }
}

impl std::fmt::Debug for KeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("KeyPair")
            .field("name", &self.name)
            .field("address", &self.address)
            .field("public_key", &hex::encode(self.public_key))
            .field("seed", &"[REDACTED]")
            .finish()
    }
}

/// Manages bot keypairs loaded from gring keystore files
pub struct KeystoreManager {
    /// Path to keystore directory
    keystore_path: PathBuf,
    /// Passphrase for decrypting keys
    passphrase: String,
    /// Cached loaded keypairs: name -> KeyPair
    keypairs: HashMap<String, KeyPair>,
    /// Address to name mapping for reverse lookup
    address_to_name: HashMap<String, String>,
}

impl KeystoreManager {
    /// Create a new KeystoreManager
    ///
    /// # Arguments
    /// * `keystore_path` - Path to directory containing .json key files
    /// * `passphrase_path` - Path to file containing the passphrase
    pub fn new(keystore_path: impl AsRef<Path>, passphrase_path: impl AsRef<Path>) -> Result<Self, KeystoreError> {
        let keystore_path = keystore_path.as_ref().to_path_buf();
        let passphrase_path = passphrase_path.as_ref();

        // Read passphrase
        let passphrase = fs::read_to_string(passphrase_path)
            .map_err(|e| KeystoreError::PassphraseNotFound(format!("{}: {}", passphrase_path.display(), e)))?
            .trim()
            .to_string();

        Ok(Self {
            keystore_path,
            passphrase,
            keypairs: HashMap::new(),
            address_to_name: HashMap::new(),
        })
    }

    /// Create from environment variables
    ///
    /// Uses:
    /// - VARA_KEYSTORE_PATH (default: "keys/Library/Application Support/gring")
    /// - VARA_PASSPHRASE_FILE (default: "keys/.passphrase")
    pub fn from_env() -> Result<Self, KeystoreError> {
        let keystore_path = std::env::var("VARA_KEYSTORE_PATH")
            .unwrap_or_else(|_| "keys/Library/Application Support/gring".to_string());
        let passphrase_path =
            std::env::var("VARA_PASSPHRASE_FILE").unwrap_or_else(|_| "keys/.passphrase".to_string());

        Self::new(keystore_path, passphrase_path)
    }

    /// Get keystore path
    pub fn keystore_path(&self) -> &Path {
        &self.keystore_path
    }

    /// Load a keypair by name (e.g., "bot_001")
    ///
    /// Keys are cached after first load.
    pub fn load_keypair(&mut self, name: &str) -> Result<&KeyPair, KeystoreError> {
        if self.keypairs.contains_key(name) {
            return Ok(self.keypairs.get(name).unwrap());
        }

        let key_path = self.keystore_path.join(format!("{}.json", name));
        let keypair = self.load_and_decrypt(&key_path, name)?;

        self.address_to_name
            .insert(keypair.address.clone(), name.to_string());
        self.keypairs.insert(name.to_string(), keypair);

        Ok(self.keypairs.get(name).unwrap())
    }

    /// Load keypair for a bot by agent ID
    ///
    /// Maps agent_id to bot name: id=1 -> "bot_001", id=20 -> "bot_020"
    pub fn load_keypair_for_agent(&mut self, agent_id: u32) -> Result<&KeyPair, KeystoreError> {
        let name = format!("bot_{:03}", agent_id);
        self.load_keypair(&name)
    }

    /// Get a previously loaded keypair by name
    pub fn get_keypair(&self, name: &str) -> Option<&KeyPair> {
        self.keypairs.get(name)
    }

    /// Get a keypair by address (must be loaded first)
    pub fn get_keypair_by_address(&self, address: &str) -> Option<&KeyPair> {
        self.address_to_name
            .get(address)
            .and_then(|name| self.keypairs.get(name))
    }

    /// Preload all bot keys (bot_001 through bot_200)
    pub fn preload_all(&mut self, count: u32) -> Result<usize, KeystoreError> {
        let mut loaded = 0;
        for i in 1..=count {
            let name = format!("bot_{:03}", i);
            match self.load_keypair(&name) {
                Ok(_) => loaded += 1,
                Err(KeystoreError::NotFound(_)) => {
                    // Key doesn't exist, skip
                    continue;
                }
                Err(e) => return Err(e),
            }
        }
        Ok(loaded)
    }

    /// List all loaded keypair names
    pub fn loaded_names(&self) -> Vec<&str> {
        self.keypairs.keys().map(|s| s.as_str()).collect()
    }

    /// Get total number of loaded keypairs
    pub fn loaded_count(&self) -> usize {
        self.keypairs.len()
    }

    /// Load and decrypt a key file
    fn load_and_decrypt(&self, path: &Path, name: &str) -> Result<KeyPair, KeystoreError> {
        // Check if file exists
        if !path.exists() {
            return Err(KeystoreError::NotFound(format!(
                "{} at {}",
                name,
                path.display()
            )));
        }

        // Read and parse JSON
        let content =
            fs::read_to_string(path).map_err(|e| KeystoreError::ReadError(format!("{}: {}", path.display(), e)))?;

        let key_file: EncryptedKeyFile =
            serde_json::from_str(&content).map_err(|e| KeystoreError::ParseError(format!("{}: {}", name, e)))?;

        // Decode the base64 encoded data
        let encoded_bytes = base64_decode(&key_file.encoded)
            .map_err(|e| KeystoreError::ParseError(format!("base64 decode failed for {}: {}", name, e)))?;

        // Decrypt using scrypt (gring format)
        let decrypted = decrypt_scrypt(&encoded_bytes, &self.passphrase)
            .map_err(|e| KeystoreError::DecryptError(format!("{}: {}", name, e)))?;

        // Extract public key from address (SS58 decode)
        let public_key = ss58_decode(&key_file.address)
            .map_err(|e| KeystoreError::InvalidFormat(format!("SS58 decode failed for {}: {}", name, e)))?;

        Ok(KeyPair {
            name: key_file.name,
            address: key_file.address,
            public_key,
            seed: decrypted,
        })
    }
}

/// Decode base64 string
fn base64_decode(input: &str) -> Result<Vec<u8>, String> {
    // Simple base64 decoding
    use std::collections::HashMap;

    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let decode_map: HashMap<char, u8> = alphabet.chars().enumerate().map(|(i, c)| (c, i as u8)).collect();

    let input = input.trim().replace(['\n', '\r', ' '], "");
    let mut output = Vec::new();
    let mut buffer = 0u32;
    let mut bits = 0u8;

    for c in input.chars() {
        if c == '=' {
            break;
        }
        let val = *decode_map
            .get(&c)
            .ok_or_else(|| format!("Invalid base64 character: {}", c))?;
        buffer = (buffer << 6) | (val as u32);
        bits += 6;
        if bits >= 8 {
            bits -= 8;
            output.push((buffer >> bits) as u8);
            buffer &= (1 << bits) - 1;
        }
    }

    Ok(output)
}

/// Decrypt scrypt-encrypted data (simplified - actual implementation may need adjustment)
///
/// gring uses substrate's keyring encryption format
fn decrypt_scrypt(encrypted: &[u8], _passphrase: &str) -> Result<Vec<u8>, String> {
    // The gring format uses substrate's encryption
    // For now, we'll use a simplified approach
    // In production, this should use the proper scrypt + nacl decryption

    // Check minimum length (salt + nonce + encrypted data)
    if encrypted.len() < 56 {
        return Err("Encrypted data too short".to_string());
    }

    // For development, we can use gclient's built-in key loading
    // which handles the decryption internally
    // This is a placeholder that returns the raw data
    // The actual decryption will be done by gclient when loading the key

    // Return the encrypted bytes - gclient will handle decryption
    // when using GearApi::init_with_keyring or similar
    Ok(encrypted.to_vec())
}

/// Decode SS58 address to public key bytes
fn ss58_decode(address: &str) -> Result<[u8; 32], String> {
    // SS58 is base58check encoding with a prefix byte
    // For Vara (prefix 137), the format is: [prefix(1-2 bytes)][pubkey(32 bytes)][checksum(2 bytes)]

    let alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let base = 58u32;

    // Base58 decode
    let mut result = vec![0u8; 64]; // Oversized buffer
    let mut result_len = 0usize;

    for c in address.chars() {
        let val = alphabet
            .find(c)
            .ok_or_else(|| format!("Invalid base58 character: {}", c))? as u32;

        let mut carry = val;
        for byte in result.iter_mut().take(result_len).rev() {
            carry += (*byte as u32) * base;
            *byte = (carry & 0xFF) as u8;
            carry >>= 8;
        }
        while carry > 0 {
            if result_len >= result.len() {
                return Err("Address too long".to_string());
            }
            result[result_len] = (carry & 0xFF) as u8;
            carry >>= 8;
            result_len += 1;
        }
    }

    // Count leading zeros in input
    let leading_zeros = address.chars().take_while(|&c| c == '1').count();

    // Reverse and add leading zeros
    let mut decoded = vec![0u8; leading_zeros];
    decoded.extend(result[..result_len].iter().rev());

    // SS58 format: [prefix][public_key(32)][checksum(2)]
    // Prefix can be 1 or 2 bytes depending on network
    // Vara uses prefix 137, which is encoded as 2 bytes

    if decoded.len() < 35 {
        return Err(format!(
            "Decoded address too short: {} bytes, expected at least 35",
            decoded.len()
        ));
    }

    // Determine prefix length (1 or 2 bytes)
    let prefix_len = if decoded[0] < 64 { 1 } else { 2 };

    // Extract public key (32 bytes after prefix)
    let pubkey_start = prefix_len;
    let pubkey_end = pubkey_start + 32;

    if decoded.len() < pubkey_end + 2 {
        return Err("Invalid SS58 address length".to_string());
    }

    let mut pubkey = [0u8; 32];
    pubkey.copy_from_slice(&decoded[pubkey_start..pubkey_end]);

    Ok(pubkey)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_base64_decode() {
        let encoded = "SGVsbG8gV29ybGQ=";
        let decoded = base64_decode(encoded).unwrap();
        assert_eq!(decoded, b"Hello World");
    }

    #[test]
    fn test_agent_id_to_name() {
        assert_eq!(format!("bot_{:03}", 1), "bot_001");
        assert_eq!(format!("bot_{:03}", 20), "bot_020");
        assert_eq!(format!("bot_{:03}", 200), "bot_200");
    }
}
