//! Keystore management for Vara Network bot accounts
//!
//! Loads seeds from a plain JSON file (`seeds.json`).
//! Seeds are 32-byte sr25519 MiniSecretKeys generated by `extract_seeds.mjs`.
//! Format: [{ "name": "bot_001", "address": "kG...", "seed": "0x<64hex>" }, ...]
//!
//! GearApi::with("0x<64hex>") uses these directly — no decryption needed.

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

use serde::Deserialize;

/// Error type for keystore operations
#[derive(Debug)]
pub enum KeystoreError {
    /// Key file not found
    NotFound(String),
    /// Failed to read key file
    ReadError(String),
    /// Failed to parse key file
    ParseError(String),
    /// Invalid key format
    InvalidFormat(String),
}

impl std::fmt::Display for KeystoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NotFound(s) => write!(f, "Key not found: {}", s),
            Self::ReadError(s) => write!(f, "Read error: {}", s),
            Self::ParseError(s) => write!(f, "Parse error: {}", s),
            Self::InvalidFormat(s) => write!(f, "Invalid format: {}", s),
        }
    }
}

impl std::error::Error for KeystoreError {}

/// Seed entry from seeds.json
#[derive(Debug, Deserialize)]
struct SeedEntry {
    name: String,
    address: String,
    /// "0x" + 128 hex chars = 64 bytes expanded sr25519 secret
    seed: String,
}

/// Decrypted keypair for signing transactions
#[derive(Clone)]
pub struct KeyPair {
    /// Key name (e.g., "bot_001")
    pub name: String,
    /// Public address (SS58 format for Vara)
    pub address: String,
    /// 32-byte sr25519 MiniSecretKey (hex with 0x prefix, 66 chars total)
    /// Used directly with GearApi::with() as SURI
    seed_hex: String,
}

impl KeyPair {
    /// Get the SURI string for gclient signing: "0x<128hex>"
    /// GearApi::with(suri) → sp_core::sr25519::Pair::from_seed_slice(64 bytes) ✓
    pub fn suri(&self) -> &str {
        &self.seed_hex
    }
}

impl std::fmt::Debug for KeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("KeyPair")
            .field("name", &self.name)
            .field("address", &self.address)
            .field("seed", &"[REDACTED]")
            .finish()
    }
}

/// Manages bot keypairs loaded from seeds.json
pub struct KeystoreManager {
    /// All loaded keypairs: name -> KeyPair
    keypairs: HashMap<String, KeyPair>,
    /// Address to name mapping for reverse lookup
    address_to_name: HashMap<String, String>,
}

impl KeystoreManager {
    /// Create a new KeystoreManager from a seeds.json file
    pub fn new(seeds_path: impl AsRef<Path>, _passphrase_path: impl AsRef<Path>) -> Result<Self, KeystoreError> {
        Self::from_seeds_file(seeds_path)
    }

    /// Load from seeds.json directly
    pub fn from_seeds_file(seeds_path: impl AsRef<Path>) -> Result<Self, KeystoreError> {
        let seeds_path = seeds_path.as_ref();

        // Try seeds.json explicitly, or look for it relative to the provided path
        let actual_path = if seeds_path.exists() && seeds_path.extension().map_or(false, |e| e == "json") {
            seeds_path.to_path_buf()
        } else {
            // Treat as directory and look for seeds.json inside or nearby
            find_seeds_json(seeds_path)?
        };

        let content = fs::read_to_string(&actual_path)
            .map_err(|e| KeystoreError::ReadError(format!("{}: {}", actual_path.display(), e)))?;

        let entries: Vec<SeedEntry> = serde_json::from_str(&content)
            .map_err(|e| KeystoreError::ParseError(format!("{}: {}", actual_path.display(), e)))?;

        let mut keypairs = HashMap::new();
        let mut address_to_name = HashMap::new();

        for entry in entries {
            // Validate seed format: must be 0x + 64 hex chars (32 bytes)
            if !entry.seed.starts_with("0x") || entry.seed.len() != 66 {
                eprintln!(
                    "[Keystore] Skipping {}: invalid seed length {} (expected 66 = 0x + 64 hex)",
                    entry.name,
                    entry.seed.len()
                );
                continue;
            }

            address_to_name.insert(entry.address.clone(), entry.name.clone());
            keypairs.insert(
                entry.name.clone(),
                KeyPair {
                    name: entry.name,
                    address: entry.address,
                    seed_hex: entry.seed,
                },
            );
        }

        println!("[Keystore] Loaded {} seeds from {}", keypairs.len(), actual_path.display());

        Ok(Self {
            keypairs,
            address_to_name,
        })
    }

    /// Create from environment variables
    pub fn from_env() -> Result<Self, KeystoreError> {
        // Look for seeds.json in standard locations
        let candidates = [
            "keys/seeds.json",
            "../keys/seeds.json",
            "../../keys/seeds.json",
        ];
        for path in &candidates {
            if Path::new(path).exists() {
                return Self::from_seeds_file(path);
            }
        }
        Err(KeystoreError::NotFound(
            "seeds.json not found. Run: cd scripts && node extract_seeds.mjs".to_string(),
        ))
    }

    /// Load a keypair by name (e.g., "bot_001")
    pub fn load_keypair(&self, name: &str) -> Result<&KeyPair, KeystoreError> {
        self.keypairs
            .get(name)
            .ok_or_else(|| KeystoreError::NotFound(name.to_string()))
    }

    /// Load keypair for a bot by agent ID
    ///
    /// Maps agent_id to bot name: id=1 -> "bot_001", id=3000 -> "bot_001" (normalized)
    pub fn load_keypair_for_agent(&self, agent_id: u32) -> Result<&KeyPair, KeystoreError> {
        let normalized = normalize_agent_id(agent_id);
        let name = format!("bot_{:03}", normalized);
        self.load_keypair(&name)
    }

    /// Get a previously loaded keypair by name
    pub fn get_keypair(&self, name: &str) -> Option<&KeyPair> {
        self.keypairs.get(name)
    }

    /// Get a keypair by address
    pub fn get_keypair_by_address(&self, address: &str) -> Option<&KeyPair> {
        self.address_to_name
            .get(address)
            .and_then(|name| self.keypairs.get(name))
    }

    /// Get key name by address (reverse lookup)
    pub fn name_by_address(&self, address: &str) -> Option<&str> {
        self.address_to_name.get(address).map(|s| s.as_str())
    }

    /// Get keystore path (compatibility)
    pub fn keystore_path(&self) -> &Path {
        Path::new("keys/seeds.json")
    }

    /// Preload all bot keys - no-op since seeds.json is loaded entirely on init
    pub fn preload_all(&self, _count: u32) -> Result<usize, KeystoreError> {
        Ok(self.keypairs.len())
    }

    /// List all loaded keypair names
    pub fn loaded_names(&self) -> Vec<&str> {
        self.keypairs.keys().map(|s| s.as_str()).collect()
    }

    /// Get total number of loaded keypairs
    pub fn loaded_count(&self) -> usize {
        self.keypairs.len()
    }
}

/// Normalize agent_id to 1..=200 range using wrap-around.
/// 0 → 1, 1 → 1, 200 → 200, 201 → 1, 202 → 2, etc.
/// Must match AddressBook::address_for_agent logic exactly.
pub fn normalize_agent_id(agent_id: u32) -> u32 {
    if agent_id == 0 { 1 } else { ((agent_id - 1) % 200) + 1 }
}

/// Find seeds.json relative to a keystore path
fn find_seeds_json(base_path: &Path) -> Result<PathBuf, KeystoreError> {
    // Try: base_path itself, base_path/seeds.json, parent/seeds.json, etc.
    let candidates = [
        base_path.join("seeds.json"),
        base_path.join("../seeds.json"),
        base_path.join("../../seeds.json"),
        PathBuf::from("keys/seeds.json"),
        PathBuf::from("../keys/seeds.json"),
    ];

    for path in &candidates {
        if path.exists() {
            return Ok(path.clone());
        }
    }

    Err(KeystoreError::NotFound(format!(
        "seeds.json not found near {}. Run: cd scripts && node extract_seeds.mjs",
        base_path.display()
    )))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_agent_id() {
        assert_eq!(normalize_agent_id(1), 1);
        assert_eq!(normalize_agent_id(100), 100);
        assert_eq!(normalize_agent_id(200), 200);
        // Wrap-around
        assert_eq!(normalize_agent_id(0), 1);
        assert_eq!(normalize_agent_id(201), 1);
        assert_eq!(normalize_agent_id(202), 2);
        assert_eq!(normalize_agent_id(400), 200);
        assert_eq!(normalize_agent_id(401), 1);
    }

    #[test]
    fn test_agent_id_to_name() {
        assert_eq!(format!("bot_{:03}", normalize_agent_id(1)), "bot_001");
        assert_eq!(format!("bot_{:03}", normalize_agent_id(20)), "bot_020");
        assert_eq!(format!("bot_{:03}", normalize_agent_id(200)), "bot_200");
    }
}
